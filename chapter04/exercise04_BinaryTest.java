package chapter04;

public class exercise04_BinaryTest {

    public static void main(String[] args){

        //进制演示
        int n1 = 0b1010;//二进制
        int n2 = 01010;//八进制
        int n3 = 1010;//十进制
        int n4 = 0x1010;//十六进制
        System.out.println("n1=" + n1 + "  n2=" + n2 + "  n3=" + n3 + "  n4=" + n4);

        //其他进制转成十进制
        /*
        二进制转为十进制
        0b1011 = 1 * 2^0 + 1 * 2^1 + 0 * 2^3 + 1 * 2^3 = 1+2+0+8=11
        八进制转为十进制
        0234 = 4*1 + 3*8 + 2*64 = 4+24+128 = 156
        十六进制转为二进制
        0x23A = 10*1 + 3*16^1 + 2*16^2 = 10+48+512 = 570
        ======================练习
        0b110001100 = 4+8+128+256 = 396
        02456 = 6*1 + 5*8 + 4*64 + 2*512 = 6+40+256+1024 = 1326
        0xA45 = 5*1 + 4*16 + 10*256 = 5+64+2560 = 2629
        */

        //十进制转化为其他进制  不断除以2、8、16取余，直到商为0
        /*======================练习
        123 = 0b01111011
        678 = 01246
        8912 = 0x22D0
        */

        //二进制转八进制，每三位一组转成对应八进制数
        /*
        0b11010101 = 0b(011)(010)(101) = 0325
         */

        //二进制转十六进制，每四位一组转成对应十六进制数
        /*
        0b11010101 = 0b(1101)(0101) = 0xD5
         */

        /*======================练习
        0b11100101 = 0b(011)(100)(101) = 0345
        0b1110010110 = 0b(0011)(1001)(0110) = 0x396
         */

        //八进制、十六进制数转化为二进制数
        /*
        0237 = 0b(010)(011)(111) = 0b10011111
        0x23B = 0b(0010)(0011)(1011) = 0b001000111011
        ======================练习
        01230 = 0b001010011
        0xAB29 = 0b1010101100101001
         */

        //源码、反码、补码
        /*
        1、	二进制的最高位是符号位，0表示正数，1表示负数；
        2、	正数的原码、反码、补码都一样；
        3、	负数的反码=符号位不变，其他位取反；
        4、	负数的补码=反码+1  负数的反码=补码-1；
        5、	0的反码、补码都是0；
        6、	Java没有无符号数；
        7、	运算是以补码形式进行运算；
        8、	看运算结果时，看原码。
         */

        //位运算符
        /*组别1
        按位与&：全1出1，否则为0
        按位或|：全0出0，否则为1
        按位异或^：相等取0，不等取1
        按位取反~：0->1,1->0
         */
        System.out.println(2&3);
        /*计算过程（仅现实1个字节，实际int类型有4个字节）
        2的原码00000010  ==>  2的补码00000010
        3的原码00000011  ==>  3的补码00000011
        按位与（补码）00000010 ==> 结果源码00000010 = 2
         */
        System.out.println(~-2);
        /*计算过程（仅现实1个字节，实际int类型有4个字节）
        -2的原码10000010  ==>  -2的反码11111101  ==>  -2的补码11111110
        按位取反（补码）00000001 ==> 结果源码000000001 = 1
         */
        System.out.println(~2);
        /*计算过程（仅现实1个字节，实际int类型有4个字节）
        2的原码00000010  ==>  2的补码00000010
        按位取反（补码）11111101 ==> 结果（反码）11111100  ==>  结果（原码）10000011 = -3
         */
        System.out.println(2|3);//3
        System.out.println(2^3);//1

        /*组别2
        算术右移>>:低位溢出，符号位不变，符号位补溢出的高位 ÷2^n
        算术左移<<:符号位不变，低位补0  *2^n
        逻辑右移（无符号右移）>>>:低位溢出，高位补0
        注意：无<<<
         */
        System.out.println(1>>2);//0
        System.out.println(-1>>2);//-1
        System.out.println(1<<2);//4




    }

}
